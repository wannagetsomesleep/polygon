#include <iostream>
#include <vector>
#include <unordered_set>

std::vector<int> removeDuplicates(const std::vector<int>& arr)
{ // 1) объявляем функция removeDuplicates, которая принимает ссылку на константный вектор целых чисел (arr) и возвращает новый вектор — уникальные элементы.{
    std::unordered_set<int> seen;   // 2) строка, которую мы ввели, создает хэш-таблицу seen, которая будет хранить уже встреченные элементы. sizeof(std::unordered_set<int>) возвращает размер структуры unordered_set, который будет примерно(+-) определять объем памяти, необходимый для самого контейнера. Однако это не учитывает дополнительную память, выделяемую для хранения элементов(!).
    std::vector<int> unique;         // 3) создаем вектор unique, который будет содержать уникальные элементы из входного вектора. Начальный размер контейнера будет зависеть от структуры std::vector<int> и дополнительной памяти для хранения элементов (size * sizeof(int)), где size — количество уникальных элементов, находящихся в векторе.

    for (int num : arr) {            // 4) сейчас начинается цикл, который проходит по каждому элементу num в векторе arr. Здесь переменная num занимает постоянное количество памяти для каждого прохода цикла, и это делает ее потребление памяти O(1).

        // Если мы еще не добавили это значение:
        if (seen.insert(num).second) { // 5) теперь мы используем метод insert у множества seen, который пытается добавить элемент num. Если элемент успешно добавлен (!то есть его не было в множестве раньше!), метод возвращает true (вторая часть пары).Операция вставки в unordered_set в среднем занимает O(1) времени, а это означает, что она выполняется быстро и не требует значительного увеличения потребления памяти.
            unique.push_back(num);        // 6) т.к. если число ещё не содержится в seen, оно добавляется в вектор unique. Каждое добавление элемента в unique занимает память, равную размеру типа int, что, в зависимости от платформы, может быть либо 4, либо 8 байт.

        }
    }
    return unique;                      // 7) эта функция возвращает вектор unique, который содержит только уникальные элементы. Память, которую мы выделяем для возвращаемого вектора unique, зависит от числа уникальных элементов, которые он будет содержать (т.е. O(n), где n — это количество уникальных элементов).
}

int main()
{
    std::vector<int> arr = { 1, 2, 3, 1, 800, 45, 45, 2, 22, 36, 800 };
    std::vector<int> result = removeDuplicates(arr); // 8) создаем вектор arr с дублирующимися значениями, который передается в функцию removeDuplicates. Результат после сохраняется в result.


    // 9) вывод результата (В этом цикле выводится каждый элемент из result).
    for (int num : result) {
        std::cout << num << " ";
    }
    return 0;
}
